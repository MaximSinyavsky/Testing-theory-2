## 1. Что такое тест дизайн?
### Тест-Дизайн
* это этап процесса тестирования, в ходе которого мы создаем тест-кейсы и намечаем структуру действий, связанных с тестированием проекта. На этом этапе команда определяет, как с минимальными усилиями расширить тестовое покрытие.
* это процесс создания планов тестирования, который обеспечивает полное покрытие функциональных требований приложения и оценку его работоспособности в реальных условиях. Это один из ключевых этапов тестирования, который помогает улучшить качество продукта и сократить затраты на его разработку.
* это процесс разработки техник и методов тестирования. Главная задача тест-дизайна — подготовить рабочую документацию, то есть разработать сценарии, которые позволят протестировать максимальное количество функций за минимальное время. Тестовая документация уникальна для каждого продукта. Разрабатывая её, тестировщик опирается на общие принципы и логику тестирования с поправкой на особенности продукта. Суть всех техник тест-дизайна — оптимизировать процесс тестирования.
* это процесс создания плана или стратегии для проведения тестирования программы или системы. Он включает в себя определение объема и способов тестирования, выбор тестовых данных, а также определение критериев успешности выполнения тестов. Задача тест-дизайна – разработать эффективные методы исследования продукта, которые займут минимум времени и выделят максимальное количество ошибок.
* это процесс который позволяет, используя определенные техники, создать оптимальное тестовое покрытие тестируемого объекта.

## 2. Для чего нужны техники тест дизайна?

### Техники тест-дизайна
* это рекомендации, советы и правила, по которым стоит разрабатывать тест для проведения тестирования приложения. Это не образцы тестов, а только рекомендации к применению. В частности различные инженеры могут работая под одним и тем же проектом создать различный набор тестов. Правильным будет считаться тот набор тестов, который за меньшее количество проверок обеспечит более полное покрытие тестами. 
### Цели применения техник тест-дизайна
* создать максимально эффективный набор кейсов, покрывающий наиболее важные аспекты тестируемого ПО, т.е. минимизировать количество тестов, необходимых для нахождения большинства серьезных ошибок.
* Придумать тесты, которые обнаружат наиболее серьезные ошибки продукта. Да, мы можем придумывать тесты, которые находят несерьезные ошибки, но тогда тестирование будет неэффективным.
* Минимизировать количество тестов, необходимых для нахождения большинства серьезных ошибок. Мы может придумать столько тестов, сколько не в состоянии будем выполнить. Поэтому перед разработчиками тестов всегда стоит задача – сохранить эффективность тестов (то есть их способность обнаруживать серьезные ошибки) без увеличения их числа.

## 3. Какие знаете техники черного ящика? Опишите их. 
* Эквивалентное разделение;
* Анализ граничных значений;
* Таблицы принятия решений;
* Анализ состояний и переходов;
* Тестирование по сценариям использования (Use case testing)
* Техника причина/следствие (Cause/Effect – CE)
* Исчерпывающее тестирование (Exhaustive Testing, ET)
* Попарное тестирование
* Техника каждого выбора
* Техника Базового выбора


### Эквивалентное разделение (Equivalence Partitioning (ISTQB/Myers 1979) / Equivalence Class Testing (Lee Copeland))
Эквивалентное разбиение подразумевает разделение данных на группы (так называемые классы эквивалентности), исходя из предположения, что все элементы одной группы обрабатываются объектом тестирования схожим образом. Теоретическое обоснование этого метода таково: если при выполнении тестового сценария обнаруживается дефект для одного из значений, относящихся к какому-либо классу эквивалентности, тот же дефект должен быть обнаружен и для любых других значений из того же класса. Следовательно, достаточно одного теста на каждый класс. Классы эквивалентности можно задать для любого элемента данных, относящегося к объекту тестирования, будь то входные данные, выходные данные, элементы конфигурации, внутренние значения, значения, привязанные ко времени, параметры интерфейса. Классы могут быть непрерывными и дискретными, упорядоченными и неупорядоченными, конечными и бесконечными. Классы не должны пересекаться, а также не должны быть пустыми.

### Анализ граничных значений (BVA - Boundary Value Analysis (Myers 1979)/range checking)
Анализ граничных значений — это метод, в котором проверка выполняется для границ классов эквивалентности. Отсюда следует, что данный метод может использоваться только для упорядоченных классов. Граничными значениями класса являются его минимальное и 
максимальное значения. В данном методе принимается, что если два элемента принадлежат к одному классу, то и все элементы, расположенные между ними, принадлежат к тому же классу. Граничные значения важны по той причине, что разработчики с большей вероятностью допускают 
ошибки именно для них. Метод обнаруживает типичные дефекты там, где программная реализация выходит за пределы значений, которые предполагаются в качестве граничных, либо граничные значения вообще отсутствуют.

### Таблица принятия решений
Таблицы решений используются для тестирования программной реализации требований к приложению (системе), где последние определяют какие комбинации условий приводят к каким результатам. Таблицы решений — это наглядный способ представления сложных логических правил, например, бизнес-правил. При создании таблицы решений в системе определяются исходные условия и результирующие действия. Эти элементы формируют строки таблицы. Каждый столбец представляет собой правило, задающее уникальную комбинацию условий, а также относящиеся к нему действия. В таблицах с краткой записью все значения, представляющие условия и действия (кроме несущественных или нереализуемых; см. ниже), отображаются в виде логических значений (истина или ложь). В то же время в таблицах с подробной записью некоторые или все условия и действия могут содержать расширенные значения (например, диапазоны чисел, области эквивалентности, дискретные значения).
Полная таблица решений имеет достаточно столбцов для покрытия всех комбинаций условий. Таблица может быть упрощена посредством удаления столбцов, содержащих невыполнимые комбинации условий. Таблица также может быть сокращена посредством объединения столбцов, которых отдельные условия не влияют на результат, в один столбец. Алгоритмы по минимизации таблиц решений выходят за рамки данной программы обучения.
Преимущество тестирования на основе таблицы решений заключается в том, что этот метод обеспечивает систематический подход к определению всех возможных комбинаций условий, некоторые из которых в противном случае могли бы быть упущены из виду. Он также позволяет найти пробелы или противоречия в требованиях. Если условий много, выполнение тестовых сценариев для всех правил таблицы может требовать большого времени, так как число правил растет экспоненциально с ростом числа условий. В таком случае, чтобы уменьшить число правил для тестирования, можно воспользоваться методом минимизации таблицы решений либо подходом, основанным на оценке рисков

### Анализ состояний и переходов
Диаграмма перехода состояний воспроизводит модель поведения системы, показывая возможные состояния и разрешенные переходы между этими состояниями. Любой переход вызывается событием, которое может к тому же сопровождаться ограничением. Подразумевается, что переходы происходят мгновенно и в некоторых случаях вызывают определенные действия программы. Типичный синтаксис, маркирующий переход, следующий: «событие [ограничение] / действие». Ограничения и действия могут быть опущены, если их нет или если тестировщик считает их неважными. Таблица переходов — модель, эквивалентная диаграмме перехода состояний. Ее строки представляют собой состояния, а столбцы — события (вместе с контрольными условиями, если таковые имеются). Записи в таблице (ячейки) представляют собой переходы и содержат конечное состояние, а также результирующие действия, если они определены. В отличие от диаграммы состояний и переходов, таблица переходов однозначно отображает недействительные переходы, которые представлены пустыми ячейками. Тестовый сценарий, основанный либо на диаграмме перехода состояний, либо на таблице переходов, обычно представлен последовательностью событий, которые приводят к последовательности переходов между состояниями (и к действиям, если необходимо). Один тестовый сценарий может покрывать (и обычно покрывает) несколько переходов состояний. 

### Тестирование по сценариям использования (Use case testing)
#### Что такое тестирование по сценариям использования?
Это подход, при котором система тестируется на основе реальных пользовательских сценариев, которые описывают, как люди взаимодействуют с программой. Тестировщики создают пошаговые инструкции для сценариев, начиная с момента входа в систему до выполнения конкретной задачи.
#### Основная цель
Цель этого типа тестирования — убедиться, что каждая функциональная часть программы работает так, как ожидается в реальных условиях. Тестирование по сценариям помогает обнаружить проблемы, которые могут возникнуть в процессе обычного использования, а не только в отдельных функциональных тестах.
#### Пример сценария использования
Например, пользователь хочет купить товар в интернет-магазине. Сценарий может включать поиск товара, добавление его в корзину, ввод информации для оплаты, подтверждение заказа, получение подтверждения на email. Этот сценарий тестируется от начала до конца.
#### Ключевые компоненты сценария использования
* Актор (пользователь) Это либо человек (конечный пользователь), либо система, которая взаимодействует с программным обеспечением. Важно учитывать разные типы пользователей — например, новый пользователь, опытный пользователь, администратор системы и т.д.
* Система Это программное обеспечение или приложение, которое тестируется. Система должна корректно обрабатывать запросы и действия пользователя на каждом этапе сценария.
* Шаги (последовательность действий)
* Сценарий использования состоит из шагов, которые пользователь предпринимает для достижения своей цели. 
* Ожидаемый результат Для каждого шага тестировщик определяет, что должно произойти. Например, при добавлении товара в корзину пользователь должен увидеть сообщение о том, что товар успешно добавлен.

### Техника причина/следствие (Cause/Effect – CE) 

Этот метод используется в тестировании для определения комбинаций условий (причин), которые могут привести к определенному результату (следствию) в системе. 

Проще говоря, это простая проверка базовых действий и их результата. 
Например, если нажать крестик в правом верхнем углу окна (причина), оно закроется (следствие), и т.д. Этот метод позволяет проверить все возможности системы, а также обнаружить баги и улучшить техническую документацию продукта.
Примерный алгоритм использования техники: 
* Выделяем причины и следствия в спецификациях.  
* Связываем причины и следствия.  
* Учитываем «невозможные» сочетания причин и следствий.  
* Составляем «таблицу решений», где в каждом столбце указана комбинация входов и выходов, т.е. каждый столбец – это готовый тестовый сценарий.  
* Расставляем приоритеты.

Эта техника помогает: 

Определить минимальное количество тестов для нахождения максимума ошибок. 
Выяснить все причины и следствия – таким образом, мы убедимся, что на любые манипуляции с системой у системы будет ответ. 
Найти возможные недочеты в логике описания приложения (что, в свою очередь, поможет улучшить документацию).

Например, QA-специалист тестирует приложение типа “записная книжка”. После ввода всех данных нового контакта и нажатия кнопки Создать (причина) приложение должно автоматически создать карточку с номером телефона, фотографией и ФИО человека (следствие). Тесты покажут, можно ли оставлять одно или несколько полей пустыми, распознает ли система кириллицу, латиницу или оба алфавита, а также другие параметры.

### Исчерпывающее тестирование (Exhaustive Testing, ET)
* это метод тестирования, при котором проверяются все возможные комбинации входных данных и сценариев использования приложения. 

Пример задачи для исчерпывающего тестирования
Представим, что у нас есть простое приложение для ввода пароля. Допустим, пароль может состоять из 12 символов, и каждый символ может быть одной из 6 возможных букв (например, A, B, C, D, E, F). В этом случае количество возможных комбинаций пароля будет равно (6^{12}) (шесть в двенадцатой степени), что составляет 2,176,782,336 комбинаций1.Преимущества исчерпывающего тестирования
Исчерпывающее тестирование имеет следующие преимущества:
* Тесты могут быть автоматизированы, что избавит от необходимости проводить работу вручную.
* Проверяет все возможные варианты данных в наборе.
* Делает программу более надежной, выявляя любые возможные ошибки.
* Выполняет повторное тестирование задач с высоким приоритетом.
* Повышает удовлетворенность клиентов от продукта.


### Тестирование каждого выбора (EC - Each choice testing):
эта стратегия требует, чтобы каждое значение каждого параметра было включено по крайней мере в один тестовый пример (Ammann & Offutt, 1994). Это также определение 1-wise coverage.

### Тестирование базового выбора (BC - Base choice testing): 
алгоритм стратегии комбинирования базового выбора начинается с определения одного базового тестового примера. Базовый тестовый пример может быть определен по любому критерию, включая простейший, наименьший или первый. Критерий, предложенный Амманном и Оффуттом (Ammann & Offutt, 1994), - это «наиболее вероятное значение» с точки зрения конечного пользователя. Это значение может быть определено тестировщиком или основано на рабочем профиле, если таковой существует. Из базового тестового примера создаются новые тестовые примеры, изменяя интересующие значения одного параметра за раз, сохраняя значения других параметров фиксированными в базовом тестовом примере. Базовый выбор включает каждое значение каждого параметра по крайней мере в одном тестовом примере, поэтому он удовлетворяет 1-wise coverage.

Попарное тестирование (Pairwise testing)

Pairwise testing - техника тест-дизайна, а именно метод обнаружения дефектов с использованием комбинационного метода из двух тестовых случаев. Он основан на наблюдениях о том, что большинство дефектов вызвано взаимодействием не более двух факторов (дефекты, которые возникают при взаимодействии трех и более факторов, как правило менее критичны). Следовательно, выбирается пара двух тестовых параметров, и все возможные пары этих двух параметров отправляются в качестве входных параметров для тестирования. Pairwise testing сокращает общее количество тест-кейсов, тем самым уменьшая время и расходы, затраченные на тестирование. Захватывающей надеждой попарного тестирования является то, что путем создания и запуска 1-20% тестов вы найдете 70-85% от общего объема дефектов.

Пример: По ТЗ сайт должен работать в 8 браузерах, используя различные плагины, запускаться на различных клиентских операционных системах, получать страницы от разных веб-серверов, работать с различными серверными, операционными системами. Итого:
* 8 браузеров;
* 3 плагина;
* 6 клиентских операционных систем;
* 3 сервера;
* 3 серверных операционных системы;

= 1296 комбинаций. Количество комбинаций настолько велико, что, скорее всего, у нас не хватит ресурсов, чтобы спроектировать и пройти тест-кейсы. Не следует пытаться проверить все комбинации значений для всех переменных, а нужно проверять комбинации пар значений переменных.

Использование всех пар для создания тест-кейсов основывается на двух техниках:
* ортогональные массивы (OA - Orthogonal Array): это двумерный массив символов. На примере выше мы составляем таблицу, где столбцы представляют собой переменные (браузер, плагин, клиентская операционная система, веб-сервер и серверная операционная система, а строки - значения каждой переменной (Chrome/Opera, Windows 8/10/11 и т.п.). После чего нужно определить ортогональный массив, у которого будет столбец для каждой переменной (каждый столбец ортогонального массива имеет столько же вариантов значений, сколько имеет ваша переменная). Используя ортогональный массив для примера выше, все пары всех значений всех переменных могут быть покрыты всего лишь 64-мя тестами.
* алгоритм Allpairs​: генерирует пары непосредственно, не прибегая к таким к ортогональным массивам. "Несбалансированный" характер алгоритма выбора всех пар требует только 48 тестов для примера. Следует отметить, что комбинации, выбранные методом ортогонального массива, могут быть не такими же, как те, которые выбраны Allpairs. Но это не важно. Важно лишь то, чтобы были выбраны все парные комбинации параметров. Это будут комбинации, которые мы хотим проверить.

## 4. Какие знаете техники белого ящика? Опишите их
* Покрытие операторов (statement coverage)
* Покрытие решений/альтернатив (decision coverage)
* Покрытие условий (condition coverage - CC)

Разработка тестов методом белого ящика (white-box test design technique): Процедура разработки или выбора тестовых сценариев на основании анализа внутренней структуры компонента или системы. (ISTQB)

Основанные на структуре методы проектирования тестирования используются для получения контрольных примеров из структурной хацврактеристики, например структуры исходного кода или структуры меню. Если эти методы применяются к исходному коду приложения, то ожидаемые результаты для контрольных примеров получаются из базиса тестирования. Выбор, какие из основанных на структуре методов проектирования тестирования использовать в каждом конкретном случае, зависит от природы базиса тестирования и от присущих рисков. (ГОСТ 56920)

### Поток данных (data flow):
Абстрактное представление последовательности и возможных изменений состояния объектов данных, при котором состояние объекта это: создание, использование либо уничтожение. (Beizer)
### Поток управления (control flow):
Последовательность событий (путей) в процессе выполнения компонента или системы. (ISTQB)

Динамическое тестирование методом белого ящика - это стратегия, основанная на внутренних путях, структуре и реализации тестируемого программного обеспечения. Тесты здесь выполняются динамически, т.е. с запуском объекта тестирования и основаны на различных видах покрытия кода (путей исполнения программы).

Глобально основных техник динамического тестирования методом белого ящика всего две:
* Тестирование потока управления (Control Flow Testing);
* Тестирование потока данных (Data Flow Testing).

Фактически, это динамическая часть одного цельного тестирования, статическая часть которого - анализ и построение графа, описывается в предыдущей теме про статический анализ, а на этом определяется целевое покрытие (Coverage Target), создаются соответствующие тест-кейсы, тесты исполняются и результаты выполнения тестов анализируются.

Уровни тестового покрытия в тестировании потока управления

Под “покрытием" имеется в виду отношение объема кода, который уже был проверен, к объему, который осталось проверить. В тестировании потока управления покрытие определяется в виде нескольких различных уровней. Заметим, что эти уровни покрытия представлены не по порядку. Это потому, что в некоторых случаях проще определить более высокий уровень покрытия, а затем определить более низкий уровень покрытия в условиях высокого.

100% покрытие операторов (Statement/node coverage). Оператор (statement) - это сущность языка программирования, обычно являющаяся минимальным неделимым исполняемым блоком (ISTQB). Покрытие операторов - это метод проектирования тестов методом белого ящика, который включает в себя выполнение всех исполняемых операторов (if, for и switch) в исходном коде как минимум один раз. Процентное отношение операторов, исполняемых набором тестов, к их общему количеству является метрикой покрытия операторов. Борис Бейзер написал: "тестирование, меньшее чем это (100% покрытие операторов), для нового программного обеспечения является недобросовестным и должно быть признано преступлением. …”. Несмотря на то, что это может показаться разумной идеей, на таком уровне покрытия может быть пропущено много дефектов и затруднен анализ покрытия некоторых управляющих структур. Покрытие операторов позволяет найти:
* Неиспользованные выражения (Unused Statements);
* Мертвый код (Dead Code);
* Неиспользуемые ветви (Unused Branches);
* Недостающие операторы (Missing Statements);

### Покрытие решений/альтернатив (decision coverage)
Покрытие решений (Decision Coverage) — это метод тестирования программ, который проверяет, чтобы каждая возможная ветвь решения в коде была выполнена хотя бы один раз.

Как проводятся тесты покрытия решений?
Каждая строка программы должна пройти через тестирование покрытия решений, чтобы найти любые потенциальные потоки принятия решений в кодах. Хорошо известно, что этот этап тестирования кода имеет решающее значение для процесса создания программ и разработки приложений. Пропуск этого этапа может серьезно снизить эффективность программы в этом модуле.
 
* Сквозное выполнение программы сканируется на начальном этапе тестирования покрытия решений, чтобы найти указания решений, разбросанные по всему коду. Здесь решения — это не что иное, как код, который имеет более одного возможного результата, может иметь более одного пути выполнения и в конечном итоге может привести к производству одного или нескольких продуктов.
* Следующие этапы подразумевают составление логической схемы принятия решений и перечисление результатов многочисленных выборов, сделанных и включенных в код приложения.
* Оценка индикаторов логического решения, собранных и созданных в предыдущих частях этого процесса тестирования, является последним и самым важным шагом в процедуре тестирования покрытия решений. Различные логические конечные точки проходят необходимые процедуры проверки и верификации. Если полученный конечный результат согласуется с предполагаемым результатом - процесс тестирования считается успешным.

### Покрытие условий (condition coverage - СС)
Тестирование покрытия условий — это тип тестирования «белого ящика», который проверяет все условные выражения в программе для всех возможных результатов условий. Его также называют покрытием предикатов .
Оно гарантирует, что тестирование включает выполнение обеих ветвей в решении, как оператор if. Если точка принятия решения имеет разные условия (используя AND или OR), покрытие условий гарантирует, что мы протестировали все различные комбинации условий.
 
Как работает покрытие условий?
* Определение точек принятия решений : первым шагом является определение точек принятия решений в коде, обычно представленных условными операторами, такими как if, else if, и else.
* Анализ условий : Каждая точка принятия решения может содержать несколько условий, которые оцениваются для определения пути выполнения. Важно проанализировать эти условия и разбить их на более простые компоненты, чтобы обеспечить комплексное тестирование.
* Создание тестовых случаев : Тестовые случаи создаются для покрытия обоих возможных результатов каждого условия – true и false. Это гарантирует, что все ветви кода будут проверены во время тестирования.
* Выполнение тестов и генерация отчетов : выполняется тестовый набор и генерируется отчет о покрытии для оценки степени достигнутого покрытия условий. Отчет выделяет протестированные и непроверенные условия, что облегчает дальнейшее уточнение тестовых случаев.

## 5. Техники основанные на опыте
* Техника предугадывания ошибок
* Исследовательское тестирование
* Тестирование на основе чек-листов

### Исследовательское тестирование (exploratory testing)

#### Исследовательское тестирование (exploratory testing)
* это одновременное изучение программного продукта, проектирование тестов и их исполнение.

Главное, что нужно помнить об исследовательском тестировании, это то, что само по себе оно не является методикой тестирования. Это, скорее, подход или образ мыслей, который можно применить к любой методике тестирования.
важное замечание: исследовательское тестирование не должно выполняться небрежно, в спешке и без подготовки. Исследовательский подход может требовать очень тщательной и длительной подготовки к определенным тестам, а накопленные за многие годы знания и умения тестировщика, применяющего данный подход, это часто невидимая, но важная форма подготовки. 
По ISTQB исследовательское тестирование – это неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для для проектирования новых и улучшенных тестов.
 Если каждый следующий тест, который мы выполняем по результатам предыдущего теста, это означает, что мы используем исследовательское тестирование.

#### Когда следует применять  исследовательское тестирование?
Самые распространенные случаи:
* вам нужно обеспечить быструю обратную связь о новом продукте или фиче
* нужно быстро изучить продукт
* вы уже провели скриптовое тестирование и хотите разнообразить своё тестирование
* вам нужно найти самый важный баг в кратчайшие сроки
* вы хотите проверить работу другого тестировщика
* вам нужно обнаружить и локализовать дефект
* вам нужно изучить состояние конкретного риска для принятия решения о необходимости покрытия этой области скриптовыми тестами
Как организовать исследовательское тестирование?
Для управления исследовательским тестированием может использоваться Session-Based Test Management. В основе этой модели лежат:
*  Тестовые сессии – ограниченные промежутки времени, в рамках которых происходит тестирование‎. При этом каждая сессия имеет тему.
* Отчеты по результатам сессий, оформленные в пригодной для парсинга и сбора статистики форме.
* Обсуждение лидом и тестировщиком результатов проведенной сессии.


### Тестирование на основе чек-листов

Чек-лист — это список, содержащий ряд необходимых проверок для какой-либо работы. Каким бы опытным ни был сотрудник, в спешке он может легко забыть важную деталь. В тестировании чек-лист — это список проверок для тестирования продукта. Чек-листы устроены предельно просто. Любой из них содержит перечень блоков, секций, страниц, других элементов, которые следует протестировать.

#### Преимущества использования чек-листов:
* Улучшается представление о системе в целом, виден статус её готовности;
* виден объём проделанной и предстоящей работы по тестированию;
* легче не повторяться в проверках и не упустить ничего важного в процессе тестирования.

Можно выделить два вида чек-листов: специальные и универсальные.

* Специальные чек-листы создаются и используются для конкретных проектов, поэтому пункты такого чек-листа соответствуют специфике проекта. Тестировщик по специальному чек-листу проверяет возможность выполнения уникального действия, предусмотренного требованиями. Такие чек-листы не подходят к использованию на других проектах.

* Универсальные чек-листы подходят для тестирования проектов одного типа. Проверка по универсальному чек-листу не привязывается к графическим элементам или конкретной реализации. Проверяется сама возможность пользователя выполнить действие. Для универсального чек-листа составляется абстрактный список проверок.Универсальные чек-листы можно использовать повторно на проектах одного типа.

Как составлять работающие чек-листы
Чтобы составить работающий чек-лист, обратите внимание на эти рекомендации:

* Один пункт = одна проверка. Минимальная полная операция проводимая тестировщиком при проверке — это один пункт чек-листа.
* При составлении чек-листа нужно опираться на требования, чтобы не тестировать то, что не существенно.

Давайте пунктам чек-листа названия по форме, общей для всех членов команды, чтобы работа с чек-листом не вызывала неоднозначных толкований. Можно договориться использовать во всех пунктах только глаголы в инфинитиве или существительные: «проверить»/ «добавить»/ «отправить» либо «проверка»/«отправка»/«добавление».

Детализируйте чек-лист в зависимости от задачи.

Объединяйте чек-листы в матрицы, где можно отразить не только сами проверки, но и условия проверки (платформа, версия продукта, сотрудник и т.п.) и статус проверки. Матрицы — это компромисс между чек-листами и тест-кейсами. Их легче поддерживать, чем тест-кейсы, так как в такой таблице отсутствуют шаги (steps). В них одна строка = одна проверка.

### Техника предугадывания ошибок

Предугадывание ошибки (Error Guessing - EG)
Метод проектирования тестов, когда опыт тестировщика используется для предугадывания того, какие дефекты могут быть в тестируемом компоненте или системе в результате сделанных ошибок, а также для разработки тестов специально для их выявления. (ISTQB)

Это одна из методик тестирования программного обеспечения, основанная на опыте и интуиции тестировщика. Техника не требует строгих формальных правил и документации, но предполагает наличие у тестировщика знания системы и понимания того, где и как могут возникнуть ошибки. Она основывается на опыте предыдущих тестирований и знаниях о типичных ошибках, которые часто возникают в подобных системах или в аналогичных ситуациях

Основные аспекты техники предугадывания ошибок
* Интуиция и опыт
Тестировщик использует свои знания и интуицию для определения мест в программе, где, по его мнению, с наибольшей вероятностью могут возникнуть ошибки
* Знание типов типичных ошибок
Тестировщик учитывает, какие ошибки чаще всего встречаются в подобных проектах, например, ошибки в обработке крайних значений, некорректное управление памятью, неправильная обработка ошибок и исключений, ошибки при работе с базой данных, неправильное управление состоянием и т. д
* Техника предугадывания ошибок часто используется в сочетании с другими методами тестирования, такими как:
** Анализ граничных значений (Boundary Value Analysis)
** Эквивалентное разбиение (Equivalence Partitioning)
** Исследовательское тестирование (Exploratory Testing)
** Тестирование по чек-листу (Checklist-based Testing)
* Анализ прошлых дефектов
Изучение прошлых ошибок, найденных в аналогичных проектах, также может помочь предсказать, где могут возникнуть проблемы
* Погружение в систему
Чем больше тестировщик понимает особенности тестируемой системы, ее архитектуру и функциональность, тем точнее он сможет предуга
дать возможные ошибки

В данной методике нет какого-либо специфического метода идентификации ошибок. Тестировщик действует, исходя из своего опыта и интуиции, чтобы заранее определить уязвимые места в тестируемом продукте. Поэтому успешность этой методики сильно зависит от опыта, навыков и глубины понимания тестируемого продукта.
В настоящее время многие продукты не уникальны по своей природе. Даже если они уникальны как продукт, то многие его части или функции уже существуют, были позаимствованы или сделаны по аналогии. Соответственно, если тестировщик уже сталкивался с подобным продуктом или его частями, он может сразу же проверить критически важный функционал в кратчайшие сроки, а затем расширить свои тесты с использованием других техник тест-дизайна.







