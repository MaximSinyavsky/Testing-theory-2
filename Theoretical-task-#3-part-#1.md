## 1. Что такое функциональное тестирование (Functional/Behavioral testing)?
Функциональное тестирование (functional testing): Тестирование, основанное на анализе спецификации функциональности компонента или системы. (ISTQB)

Функциональное тестирование выполняется чтобы убедиться, что каждая функция программного приложения ведет себя так, как указано в документе с требованиями.

### Для функционального тестирования принято использовать две техники:
1. Тестирование на основе требований: содержит все функциональные спецификации, которые составляют основу для всех тестов, которые будут проводиться;
2. Тестирование на основе бизнес-сценариев: содержит информацию о том, как система будет восприниматься с точки зрения бизнес-процесса;

## 2. Что такое нефункциональное тестирование (Non-Functional testing)?
Нефункциональное тестирование проводится для проверки нефункциональных требований приложения, таких как производительность, безопасность, совместимость, надежность, удобство использования и т. д. В большинстве случаев это выполняется методом black box testing. Оно проверяет, соответствует ли поведение системы требованиям по всем аспектам, не охваченные функциональным тестированием.

### Нефункциональные требования могут быть отражены как:
1. Пользовательские / Технические истории (User /Technical Stories): запись нефункциональных требований в виде пользовательской истории такая же, как и запись любых других требований. Единственная разница между пользователем и технической историей заключается в том, что пользовательская история требует обсуждения и имеет видимость (? visibility);
2. В критериях приемки (Acceptance criteria): это точка, которая определяется для принятия продукта заказчиком. Нефункциональное требование должно быть включено в критерии приемки, но иногда невозможно проверить нефункциональные требования с каждой историей, то есть с каждой итерацией. Следовательно, требования следует добавлять или тестировать только с соответствующей итерацией;
3. В артефактах (Artifact): для нефункциональных требований следует подготовить отдельный артефакт, это, в свою очередь, поможет лучше понять, что нужно тестировать и как это можно делать в итерациях;

## 3. Какие виды тестирования относятся к функциональному тестированию?
### Основные виды функционального тестирования:
#### 1. Unit Testing:
модульное тестирование обычно выполняется разработчиком и влечет за собой написание тестов, которые будут вызывать методы в каждом модуле и проверять их, передавая требуемые параметры и проверяя соответствие возвращаемого значения ожидаемому. Покрытие кода - важная часть модульного тестирования, где должны существовать test cases, охватывающие:
* Line coverage;
* Code path coverage;
* Method coverage;
#### 2. Smoke Testing:
тестирование, которое проводится после выпуска каждой сборки. Это также называется build verification testing;
#### 3. Sanity Testing:
тестирование, которое проводится для того, чтобы убедиться, что все основные и жизненно важные функции приложения / системы работают правильно. Обычно это делается после Smoke Testing;
#### 4. Regression Tests:
тестирование проводится для того, чтобы убедиться, что добавление нового кода, улучшений, исправление ошибок не нарушает существующую функциональность или не вызывает нестабильности и ПО все еще работает в соответствии со спецификациями. Регрессионные тесты не должны быть такими обширными, как фактические функциональные тесты, но должны гарантировать объем покрытия, подтверждающий стабильность функциональности;
#### 5. Integration Tests:
когда система полагается на несколько функциональных модулей, которые работают по отдельности, но должны работать согласованно когда объединены вместе, чтобы достичь сквозного сценария, проверка таких сценариев называется интеграционным тестированием;
#### 6. Beta/Usability Testing:
продукт демонстрируется реальному пользователю в среде, приближенной к проду, и они тестируют продукт. Это похоже на User Acceptance testing;
#### 7. System testing:
тестирование, которое выполняется для всей системы, чтобы проверить, работает ли она должным образом после интеграции всех модулей или компонентов;
#### 8. End to end testing:
проводится для проверки функциональности продукта. Это тестирование выполняется только после завершения тестирования системной интеграции, включая функциональные и нефункциональные требования;

## 4. Какие виды тестирования относятся к нефункциональному тестированию?
### Виды нефункционального тестирования (список не полный):
* Тестирование производительности (Performance Testing)
* Нагрузочное тестирование (Load Testing)
* Стрессовое тестирование (Stress Testing)
* Объемное тестирование (Volume Testing)
* Тестирование восстановления (Recovery Testing)
* Тестирование отказоустойчивости (Failover Testing)
* Тестирование эффективности (Efficiency Testing)
* Тестирование аварийного восстановления (Disaster Recovery Testing)
* Тестирование установки (Installation Testing)
* Тестирование документации (Documentation Testing)
* Тестирование на удобство использования (Usability Testing)
* Тестирование совместимости (Compatibility Testing)
* Тестирование обслуживаемости (Maintainability Testing)
* Тестирование безопасности (Security Testing)
* Тестирование масштабируемости (Scalability Testing)
* Тестирование выносливости (Endurance Testing)
* Тестирование надежности (Reliability Testing)
* Тестирование соответствия (Compliance Testing)
* Тестирование локализации (Localization Testing)
* Тестирование интернационализации (Internationalization Testing)
* Тестирование переносимости (Portability Testing)

## 5. Что такое Статическое/Динамическое тестирование?
Тестирование, как статическое так и динамическое, должно быть направлено на получение обоих типов подтверждения (верификация и валидация), хотя и должно допускать, что подтверждение не будет получено немедленно из-за обнаружения дефектов. (ГОСТ 56920)

### Статическое тестирование (Static Testing, Non-execution technique или verification) 
подразумевает проверку вручную или с помощью инструментов программного кода без его запуска, а также проверку документации.

### Почему требуется статическое тестирование:
* Обнаружение ошибок / недостатков на ранних этапах: при создании ПО нельзя полагаться исключительно на динамическое тестирование, поскольку оно выявляет ошибки или недостатки программного продукта на более позднем этапе, что может стоить разработчикам много времени и усилий для отладки;
* Увеличение размера ПО: по мере увеличения размера программного продукта становится трудно справиться с ним, поскольку эффективность покрытия кода снижается;
* Динамическое тестирование занимает много времени: несмотря на то, что динамическое тестирование выявляет ошибку и предоставляет некоторые подробности относительно ошибки, исправление ошибки по-прежнему требует времени и усилий, поскольку оно включает в себя обнаружение сбоя от тестового примера до основной причины, что в целом усложняет процесс;
* Динамическое тестирование дорогое: как упоминалось ранее, для динамического тестирования требуются тестовые примеры, и выполнение этого само по себе является дорогостоящим, потому что тестовые примеры должны быть сначала созданы, затем выполнены и проверены, а также должны поддерживаться, что требует большой работы со стороны тестировщиков;

#### Динамическое тестирование (Dynamic Testing, Execution technique или validation)
подразумевает запуск кода для проведения функциональных и нефункциональных проверок ПО. Основная цель этого тестирования - подтвердить, что программный продукт работает в соответствии с требованиями бизнеса. Преимуществами динамического тестирования являются выявление сложных дефектов, которые не могут быть обнаружены статическим тестированием, обнаружение угроз безопасности, проблем с производительностью и т.п.

## 6. Что такое Черный/Серый/Белый ящик тестирования (White/Black/Grey Box testing)?

### Тестирование методом белого ящика (White Box Testing)
Тестирование методом белого ящика (white-box testing): Тестирование, основанное на анализе внутренней структуры компонента или системы (ISTQB).

Тестирование методом белого ящика (также: прозрачного, открытого, стеклянного ящика; основанное на коде или структурное тестирование) - метод тестирования ПО, который предполагает, что внутренняя структура/устройство/реализация системы известны тому, кто её тестирует. Мы выбираем входные значения, основываясь на знании кода, который будет их обрабатывать. Точно так же мы знаем, каким должен быть результат этой обработки. Знание всех особенностей тестируемой программы и ее реализации - обязательны для этой техники. Тестирование белого ящика - углубление во внутреннее устройство системы, за пределы ее внешних интерфейсов.

Техника белого ящика применима на разных уровнях тестирования - модульном, интеграционном и системном, но чаще применяется для юнит-тестирования этого участка кода самим разработчиком или SDET. Тестирование белого ящика - это больше, чем тестирование кода: это тестирование путей.​ Обычно тестируемые пути находятся внутри модуля (модульное тестирование). Но мы можем применить эту же методику для тестирования путей между модулями внутри подсистем, между подсистемами внутри систем, и даже между целыми системами.

### Тестирование методом черного ящика (Black Box Testing)
Тестирование методом черного ящика (black box testing): Тестирование, функциональное или нефункциональное, без знания внутренней структуры компонента или системы (ISTQB).

Тестирование методом «черного ящика» - это стратегия, в которой тестирование основано исключительно на требованиях и спецификациях, при этом мы не знаем, как устроена внутри тестируемая система и работаем исключительно с внешними интерфейсами тестируемой системы или компонента. Тестирование черного ящика может быть применено на всех уровнях - модульном, интеграционном, системном и приемочном.

#### Functional Testing:
этот тип касается функциональных требований или спецификаций приложения (functional requirements or specifications). Здесь различные действия или функции системы тестируются путем предоставления входных данных и сравнения фактического выхода с ожидаемым выходом. Например, когда мы тестируем раскрывающийся список, мы нажимаем на него и проверяем, что он раскрывается и все ожидаемые значения отображаются. Вот несколько основных типов функционального тестирования:
* Smoke Testing;
* Sanity Testing;
* Integration Testing;
* System Testing;
* Regression Testing;
* User Acceptance Testing;

#### Non-Functional Testing:
Помимо функциональности требований, есть несколько нефункциональных аспектов, которые необходимо протестировать, чтобы улучшить качество и производительность приложения. Несколько основных типов нефункционального тестирования включают:
* Usability Testing;
* Load Testing;
* Performance Testing;
* Compatibility Testing;
* Stress Testing;
* Scalability Testing;

### Тестирование методом серого ящика (Grey Box Testing)
Тестирования методом серого ящика вообще нет в ISTQB, тем не менее много где можно встретить упоминания этого типа тестирования. В целом оно определяется как метод тестирования ПО, который предполагает комбинацию White Box и Black Box подходов или как дополненный черный ящик. Т.е., внутреннее устройство/код известны/используется лишь частично, и, например, имея доступ к внутренней структуре и алгоритмам работы ПО, можно написать более эффективные тест-кейсы, но само тестирование проводится с помощью техники черного ящика, то есть, с позиции пользователя.

## Что такое Компонентное (Component or Unit Testing) /Интеграционное (Integration Testing) /Системное (System Testing)/Приемочное тестирования (Acceptance Testing)?

### Модульное тестирование (оно же юнит-тестирование)
используется для тестирования какого-либо одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде. Очевидно, что это тестирование методом белого ящика и чаще всего оно проводится самими разработчиками. Целью тестирования модуля является не демонстрация правильного функционирования модуля, а демонстрация наличия ошибки в модуле, а также в определении степени готовности системы к переходу на следующий уровень разработки и тестирования. На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов. Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования. Изоляция тестируемого блока достигается с помощью заглушек (stubs), манекенов (dummies) и макетов (mockups).

### Компонентное тестирование
тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, без интеграции с другими компонентами. Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. Это один из самых частых типов тестирования черного ящика, который проводится командой QA. Для каждого из этих компонентов будет определен сценарий тестирования, который затем будет приведен к Test case высокого уровня -> детальным Test case низкого уровня с предварительными условиями.

##### Исходя из глубины уровней тестирования, компонентное тестирование можно классифицировать как:
* Тестирование компонентов в малом (CTIS - Component testing In Small): тестирование компонентов может проводиться с или без изоляции остальных компонентов в тестируемом программном обеспечении или приложении. Если это выполняется с изоляцией другого компонента, то это называется CTIS;
* Тестирование компонентов в целом (CTIL - Component testing In Large) - тестирование компонентов, выполненное без изоляции других компонентов в тестируемом программном обеспечении или приложении;

### Интеграционное тестирование (Integration testing)
Интеграционное тестирование (integration testing): Тестирование, выполняемое для обнаружения дефектов в интерфейсах и во взаимодействии между интегрированными компонентами или системами. См. также тестирование интеграции компонентов, системное интеграционное тестирование. (ISTQB)

#### Уровни интеграционного тестирования:
1. Компонентный интеграционный уровень (CIT - Component Integration testing): Проверяется взаимодействие между компонентами одной системы после проведения компонентного тестирования. Программные компоненты или модули могут быть определены в разное время совершенно разными группами спецификаций, component integration testing выполняется чтобы убедиться, что даже после различий в разработке модулей интеграция всего работает вместе. В этом случае также важно учесть отрицательные случаи, так как компоненты могут делать предположения относительно данных;
2. Системный интеграционный уровень (SIT - System Integration testing): - это полное тестирование всей системы, состоящей из множества подсистем. Основная цель SIT - обеспечить правильное функционирование всех зависимостей программных модулей и сохранение целостности данных между отдельными модулями всей системы. SUT (System Under Test) может состоять из аппаратного обеспечения, базы данных, программного обеспечения, комбинации аппаратного и программного обеспечения или системы, требующей взаимодействия с человеком (HITL - Human in the Loop Testing). SIT имеет предварительное условие, при котором несколько базовых интегрированных систем уже прошли системное тестирование. Затем SIT проверяет необходимые взаимодействия между этими системами в целом. Результаты SIT передаются в UAT (пользовательское приемочное тестирование);

#### Подходы к интеграционному тестированию:
1. Подход Большого взрыва (Big Bang Approach): “Вид подхода к интеграционному тестированию, при котором элементы программного или аппаратного обеспечения, или и то и другое, собираются в компонент или в целую систему сразу, а не по этапам.” ( IEEE 610). Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если Test case и их результаты записаны неверно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования;
2. Инкрементальный подход (Incremental Approach): при таком подходе тестирование выполняется путем объединения двух или более логически связанных модулей. Затем другие связанные модули поэтапно добавляются и тестируются для правильного функционирования. Процесс продолжается до тех пор, пока все модули не будут соединены и успешно протестированы. Осуществляется разными методами:
* Нисходящий подход (Top-Down Approach): Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Преимущества: Локализация неисправностей проще. Возможность получить ранний прототип. Основные недостатки дизайна могут быть найдены и исправлены в первую очередь. Недостатки: Нужно много заглушек. Модули на более низком уровне тестируются недостаточно;
* Восходящий подход (Bottom-Up Approach): В восходящей стратегии каждый модуль на более низких уровнях последовательно тестируется с более высокоуровневыми модулями, пока не будут протестированы все модули. Требуется помощь драйверов для тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения. Пример низкоуровневого модуля - модуль, который заведует хранением токенов авторизации. Высокоуровневый - модуль авторизации, в состав которого помимо прочего входит модуль токенов. Преимущества: Локализация ошибок проще. Не тратится время на ожидание разработки всех модулей, в отличие от подхода Большого взрыва. Недостатки: Критические модули (на верхнем уровне архитектуры ПО), которые контролируют поток приложения, тестируются последними и могут быть подвержены дефектам. Ранний прототип невозможен;
* Гибридный/сэндвич-подход (Sandwich/Hybrid/Bi-Directional Approach): Представляет собой комбинацию восходящего и нисходящего подходов. Здесь целью является средний слой, в то время как драйверы заменяют верхний слой, а заглушки нижний пока компоненты этих слоев не будут разработаны;

## Что такое Позитивное/Негативное тестирование?

## Что такое Gorilla testing/ Monkey testing?

## Что такое Альфа (Alpha Testing)/Бета тестирование (Beta Testing)? Что такое Интуитивное/Исследовательское тестирование?

## Что такое Дымовое (Smoke)/Ре-тест (Re-test)/ Санити(Sanity)/Регрессионное (Regression) тестирование?

## Что такое Тестирование нового функционала/ Приемочное тестирование?

## Что такое Ручное/Автоматизированное/Полуавтоматизированное тестирование?

## На основании чего происходит разработка тестовых сценариев? Что такое Frontend/Backend?
