# Тестовая документация:
## 1. Что такое тест план?
Тест-план — это артефакт тестирования, который описывает стратегию тестирования, цели, подходы и ресурсы для тестирования ПО. В нем обычно подробно расписывают задачи, которые нужно выполнить, и методы, которые будут использовать. Также указывают ресурсы и сроки этого проекта.

Тест план имеет четкую структуру, установленную IEEE 829 (Ай-Трипл-И)— отраслевым стандартом для документации тестирования программ и систем. Это значит, что вы можете подготовить шаблон и использовать его для любого проекта, заполняя конкретными данными.

## 2. Что должен описывать тест план?
#### Как написать план тестирования
#### Хороший тест план должен как минимум отвечать на следующие вопросы:
* что надо тестировать (объект тестирования: система, приложение, оборудование)
* что будете тестировать (список функций и компонент тестируемой системы)
* как будете тестировать (стратегия тестирования - виды тестирования и их применение по отношению к тестируемому объекту)
* когда будете тестировать (последовательность проведения работ: подготовка, тестирование, анализ результатов, в разрезе запланированных фаз разработки проекта)
* критерии начала тестирования (к таким критериям можно отнести готовность тестовой платформы (тестового стенда), законченность разработки требуемого функционала, наличие всей необходимой документации)
* критерии окончания тестирования
#### (когда результаты тестирования удовлетворяют критериям качества продукта:
* требования к количеству открытых багов выполнены
* выдержан определенный период без изменения исходного кода приложения Code Freeze (CF)
* выдержан определенный период без открытия новых багов Zero Bug Bounce (ZBB)
#### Далее, Тест-план нужно дополнить следующими пунктами:
* Окружение тестируемой системы (версии ОС, браузеров)
* Необходимые для тестирования ресурсы
* программные ресурсы - инструменты для тестирования (например, Jira, TestRail, Selenium)
* аппаратные ресурсы
* человеческие ресурсы
* временные ресурсы
* финансовые ресурсы
* тестовые данные
* Риски и их разрешение

## 3. Какие вы знаете Виды тест планов?
### Виды тест планов
Чаще всего на практике приходится сталкиваться со следующими видами тест планов:
* Мастер тест план (project test plan or Master Test Plan)
* Тест план (Test Plan), или детальный тест план
* План приемочных испытаний (Product Acceptance Plan) — документ, описывающий набор действий, связанных с приемочным тестированием (стратегия, дата проведения, ответственные работники и т.д.)
#### Мастер Тест-План (Master Test Plan): “Главный план тестирования (master test plan, project test plan):
План тестирования, обычно охватывающий несколько уровней тестирования.” (ISTQB). Это может быть как единственный базовый план, так и главный в иерархии нескольких планов, самый статичный и высокоуровневый. 
 
Нужен когда:
* продукт имеет множество релизов или итераций, между которыми сохраняется общая информация, которую нет смысла повторять;
* разные тестовые команды работают над одним продуктом, выполняя различные задачи, которые необходимо объединить в рамках одного документа;

#### Детальный Тест-план (Phase Test plan): Уровневый план тестирования (level test plan): 
Детальный план составляется на каждый релиз/итерацию или для каждой команды в рамках проекта и является динамическим, т.е. может претерпевать изменения по необходимости. 

Его основная цель - кратко и доходчиво отразить задачи тестирования. Детальных планов может быть несколько для отдельных модулей ПО или команд тестирования. Кроме того, могут быть созданы планы для отдельных уровней тестирования (Level Test Plan) или видов тестирования. В Agile проектах могут быть планы итерационного тестирования (iteration testing plans) для каждой итерации;

#### План приемочных испытаний (Acceptance Test Plan, ПСИ):
план приемочного тестирования отличают от обычного плана тестирования факторы, которые приводят к принятию бизнес-решения. План приемочного тестирования - это один из жизненно важных документов, который содержит руководство по выполнению приемочного тестирования для конкретного проекта. Пишется на основе бизнес-требований (Business Requirements). Ревью этого плана обычно выполняется by Managers/Business Analysts/Customers.

В повседневной жизни на проекте может быть один мастер тест план и несколько детальных тест планов, описывающих отдельные модули одного приложения.

## 4. Что такое чек лист?
В общем смысле, чек-лист - это набор идей: идей по тестированию, идей по разработке, идей по планированию и управлению — любых идей. 

Чек-лист в тестировании - это список проверок, которые необходимо провести для тестирования приложения или его части. 

Важно понять, что нет и не может быть никаких запретов и ограничений при разработке чек-листов — главное, чтобы они помогали в работе. Иногда чек-листы могут даже выражаться графически (например, с использованием ментальных карт или концепт-карт), хотя традиционно их составляют в виде многоуровневых списков.

Для того чтобы чек-лист был действительно полезным инструментом, он должен обладать рядом важных свойств:
* Логичность
* Последовательность и структурированность
* Полнота и неизбыточность.
Можно выделить две разновидности чек-листов: специальные и универсальные. Специальные создаются для конкретного проекта, проверки отражают его специфику. Универсальные подходят для тестирования проектов одного типа, проверки в них не привязываются к графическим элементам или конкретной реализации.

## 5. Перечислите возможные атрибуты чек листа.
### Обязательные части чек-листа:
* Шапка:  содержит информацию о названии приложения, его версии, окружении, на котором проводится тестирование (версия ОС, браузера, эмулятора), ответственного за тестирование, дату тестирования 
* Тестируемые модули, субмодули: например, регистрация, аутентификация авторизация
* Список проверок: они должны отражать основную суть, без лишней детализации
* Статус: информация о статусе прохождения проверки:
### Дополнительные части чек-листа
* Ожидаемый результат:  то, что мы ожидаем увидеть после запуска проверки согласно требованиям
* Типы тестирования: к какому типу относится проверка?
* Отчеты о дефекте: ссылки на отчеты о дефектах для прослеживаемости
* Заметки: если нужно добавить комментарии
* Также у проверок может быть уникальный идентификатор для прослеживаемости.

## 6. Перечислите варианты статусов при прохождении чек листа.
* Passed (Пройден) — проверка прошла успешно. Используется, когда тест полностью соответствует ожидаемым результатам.
* Failed (Провален) — проверка провалилась. Это значит, что обнаружены несоответствия между фактическим результатом и ожидаемым.
* Blocked (Заблокирован) — тест не может быть выполнен из-за каких-то внешних причин. Например, недостаток данных, сбои в системе или зависимость от другой задачи, которая не завершена.
* Skipped (Пропущен) — тест был намеренно пропущен. Может быть, проверка нерелевантна для текущей версии, задачи или её выполнение не требуется.
* Not Run (Не выполнен) — тест ещё не был выполнен. Этот статус ставится до того, как проверка началась.
* N/A (Not Applicable, не применимо) означает, что проверка или тест не относится к текущему контексту, сценарию или продукту. 

## 7. Что такое тест кейс?
Тестовый сценарий (test case): Набор входных значений, предусловий выполнения, ожидаемых результатов и постусловий выполнения, разработанный для определенной цели или тестового условия, таких как выполнения определенного пути программы или же для проверки соответствия определенному требованию. (IEEE 610)

Тестовый сценарий высокого уровня (high level test case): Тестовый сценарий без конкретных (уровня реализации) значений входных данных и ожидаемых результатов. Использует логические операторы, а экземпляры реальных значений еще не определены и/или доступны. (ISTQB)

Тестовый сценарий низкого уровня (low level test case): Тестовый сценарий с конкретными (уровня реализации) значениями входных данных и ожидаемых результатов. Логические операторы из тестовых сценариев высокого уровня заменяются реальными значениями, которые соответствуют целям этих логических операторов. (ISTQB)

Test case (тест-кейс, тестовый пример/случай) - это артефакт, описывающий совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации тестируемой функции или ее части. Более строго - формализованное описание одной показательной проверки на соответствие требованиям прямым или косвенным.

## 8. Перечислите атрибуты тест кейса?
### Содержание тест-кейса:
* Идентификатор набора тестов (Test Suite ID): Идентификатор набора тестов, в которых входит этот кейс;
* Идентификатор тестового кейса (Test Case ID): Идентификатор самого кейса;
* Заголовок кейса (Test Case Summary): Краткое и емкое название проводимой проверки;
* Связанное требование (Related Requirement): Идентификатор требования, к которому относится / отслеживается данный тестовый пример;
* Предварительные условия (Prerequisites): Любые предпосылки или предварительные условия, которые должны быть выполнены перед выполнением теста;
* Шаги выполнения (Test Script / Procedure): Шаги выполнения теста;
* Тестовые данные (Test Data): Тестовые данные или ссылки на тестовые данные, которые должны использоваться при проведении теста;
* Ожидаемый результат (Expected Result): результат, который мы ожидаем получить после выполнения шагов теста;
* Статус пройден или не пройден (Status): Другие статусы могут быть «Не выполнено», если тестирование не проводится, и «Заблокировано», если тестирование заблокировано;
* Заметки (Remarks): Любые комментарии к тесту или выполнению теста;
* Создано (Created By): Имя автора тестового примера;
* Дата создания (Date of Creation): Дата создания тестового примера (опционально модификации);
* Выполнено (Executed By): Имя человека, выполнившего тест;
* Дата выполнения (Date of Execution): Дата выполнения теста;
* Тестовое окружение (Test Environment): оборудование / программное обеспечение / сеть, в которых выполнялся тест, т.е. все необходимые сведения об окружении, чтобы можно было воспроизвести полученный результат.

## 9. Перечислите виды тест кейсов?
### В иностранной литературе часто делят кейсы на две категории:
* Высокоуровневый тест-кейс (high level test case или logical test case) - тест-кейс без конкретных входных данных и ожидаемых результатов. Как правило, ограничивается общими идеями и операциями, схож по своей сути с подробно описанным пунктом чек-листа. Достаточно часто встречается в интеграционном тестировании и системном тестировании, а также на уровне smoke. Может служить отправной точкой для проведения исследовательского тестирования или для создания низкоуровневых тест-кейсов.
* Низкоуровневый тест-кейс (low level test case) - тест-кейс с конкретными входными данными и ожидаемыми результатами. Представляет собой «полностью готовый к выполнению» тест-кейс и вообще является наиболее классическим видом тест-кейсов. Начинающих тестировщиков чаще всего учат писать именно такие тесты, т.к. прописать все данные подробно - намного проще, чем понять, какой информацией можно пренебречь, при этом не снизив ценность тест-кейса.

## 10. Что такое тестовый набор (Test Suite)?
* это коллекция различных тестовых примеров, предназначенных для проверки поведения или набора поведений программного приложения или системы. Группировка тестов в тестовые наборы помогает эффективно управлять, выполнять и предоставлять результаты тестирования.

Эффективно выступая в качестве контейнера для тестовых примеров, такой набор содержит точные сведения и цели для каждого отдельного тест-кейса. Кроме того, он содержит важную информацию о конфигурации системы, необходимой для процесса тестирования. Отличительной особенностью набора является использование различных стадий для обозначения статуса выполнения теста – от активного, выполняемого до завершенного.

В некоторых случаях тестовые наборы могут использоваться для организации соответствующих тест-кейсов. В зависимости от системы это может быть набор для всей системы или же набор smoke-тестов, включающий проверку только критически важной функциональности. Кроме того, они могут состоять из всех тестов и указывать, следует ли использовать тот или иной тест в качестве проверки smoke или для конкретной функциональности.

Как показано на рисунке ниже, план тестирования разделяется на тестовые наборы. Они могут быть дополнительно сегментированы по количеству тестовых случаев.

## 11. Что такое баг репорт?
* это технический документ, который подробно описывает ошибку в работе программы, приложения или другого ПО. Его составляет тестировщик, чтобы разработчикам было понятно, что работает неправильно, насколько дефект критичен и что нужно исправить.
* часть рабочего процесса. В них фиксируют наличие ошибки, назначают ответственного за исправление. Если сообщить об ошибке в рабочем чате, о ней скорее всего забудут. Каждый член команды подумает, что ошибку исправит другой, и в итоге она так и останется в коде.

### Виды багов
В зависимости от места или условий обнаружения дефектов они классифицируются на несколько видов: функциональные и нефункциональные.

## 12. Какое нужно соблюдать правило в баг репорте для хорошего Summary?
### Необходимо составить предложение, в котором факты дефекта изложены в следующей последовательности:
* Где?: В каком месте интерфейса пользователя или архитектуры программного продукта находится проблема. Причем, начинайте предложение с существительного, а не предлога.
* Что?: Что происходит или не происходит согласно спецификации или вашему представлению о нормальной работе программного продукта. При этом указывайте на наличие или отсутствие объекта проблемы, а не на его содержание (его указывают в описании). Если содержание проблемы варьируется, все известные варианты указываются в описании.
* Когда? (При каких обстоятельствах?): В какой момент работы программного продукта, по наступлению какого события или при каких условиях проблема проявляется.

## 13. Перечислите атрибуты баг репорта?
* ID -порядковый номер
* Environment - окружение, на котором найден баг
* Severity (Серьезность) - атрибут, характеризующий влияние дефекта на работоспособность приложения. Проставляется тестировщиком или техническим специалистом, который может оценить степень влияния дефекта на работу системы
* Priority (Приоритет) - атрибут, указывающий на очередность выполнения задачи или устранения дефекта. Проставляется руководителем или менеджером проекта
* Summary (Тайтл, описание) - раздел, который кратко передает суть бага одним предложением.
* Precondition (Предварительное условие) - используется, если предварительно систему нужно приводить к состоянию, пригодному для проведения проверки
* Steps (Шаги для воспроизведения) - последовательность действий для воспроизведения бага 
* Expected result (Ожидаемый результат) - описание того, как программа или функциональность должны работать
* Actual result (Фактический результат) -  описание того, что происходит на самом деле
* Attachment (Вложения) - файл с логами, скриншот/видео или любой другой документ, который может помочь прояснить причину ошибки или указать на способ решения проблемы
* Author (Автор) - создатель баг-репорта
* Assigned To (Назначен на) - имя сотрудника, назначенного на решение проблемы.

## 14. Опишите жизненный цикл бага.

### Жизненный цикл бага (bug workflow) 
– последовательность этапов, которые проходит баг на своем пути с момента его создания до окончательного закрытия.
### Цель жизненного цикла бага
– в координации работы с багом и легкой передаче его текущего статуса различным ответственным лицам.Назначение багам статуса позволяет лучше отслеживать фактический прогресс их жизненного цикла. Это делает процесс устранения бага системным и эффективным.
Количество состояний, через которые проходит баг, варьируется от проекта к проекту
### Список статусов бага
* Новый
Первый статус в цикле, New, или Обнаружен, означает, что дефект обнаружен тестировщиком, зарегистрирован, и по нему создан баг-репорт, на основе которого разработчик потом будет искать и устранять дефект.
* Назначен
Когда новый дефект подтвержден и принят в обработку разработчиком, получает статус Назначен (Assigned). Как правило назначается ответственный за устранение этого бага (поэтому статус еще может называться «Назначен НА кого-то»). 
* Решен (Resolved)
На этом этапе,а иногда и ранее мы можем сталкиваться с таким понятием как резолюция
1. Резолюция – это решение принятое по дефекту. Резолюция – очень важный атрибут, напрямую связанный со статусом, т. е. резолюция – это детализация статуса.
2. FIXED (Решено) – стандартная резолюция, означающая, что задание выполнено или баг исправлен
* Ожидает повторного тестирования
В статусе Pending Retest дефект ожидает, когда тестировщики повторно проверят его, убедившись что все ОК, код теперь исправлен.
* Повторно тестируется
Retest: тестировщик еще раз проверяет этот дефект, и убедившись что он устранен разработчиками, верифицирует это и закрывает дефект, а в противном случае переоткрывает.
* Повторно открыт
Если повторное тестирование не смогло устранить баг, обнаруживается снова, ему присваивается статус Reopen. Баг открывается опять и еще раз проходит по циклу.
* Проверен
Тестировщик еще раз проверяет (верифицирует) баг, повторно исправленный разработчиком, и если теперь он не проявляется, присваивается статус Verified.
* Закрыт
Когда дефект больше не существует и полностью исправлен, тестировщик меняет статус дефекта на “Closed”.

## 15. Что такое Priority?
характеристика, которая показывает необходимость скорейшего устранение дефекта. Чем выше приоритет, тем быстрее нужно приступить к работе по исправлению.

## 16. Перечислите классификации Priority.
* P1 Наивысший (Critical) (ASAP, as soon as possible) 
Ошибка должна быть исправлена настолько быстро, насколько это возможно и может варьироваться от «в ближайшем билде» до единиц минут.
* P2 Высокий (High)
Ошибка должна быть исправлена как можно быстрее, т.к. ее наличие является критической для проекта.
* P3 Средний (Medium)
Ошибка должна быть исправлена, ее наличие не является критичной, но требует обязательного решения.
* P4 Низкий (Low)
Ошибка должна быть исправлена, ее наличие не является критичной, и не требует срочного решения.

## 17. Что такое Severity?
это атрибут, характеризующий влияние дефекта на работоспособность приложения.

## 18. Перечислите классификации Severity.
* S1 – Блокирующий (Blocker) – дефект полностью блокирует выполнение функционала, нет никакого способа его обойти. Если провести аналогию с закрытым помещением и дверью – то дверь закрыта, у вас нет никакой возможности её открыть и покинуть помещение. Окон нет, ключ к двери не подходит.
* S2 – Критический (Critical) – дефект блокирует часть функциональности, но есть альтернативный путь для его обхода. По аналогии с помещением и дверью: вы можете покинуть помещение через окно, хотя дверь по-прежнему закрыта и ключ к ней не подходит.
* S3 – Значительный (Major) – дефект, указывающий на некорректную работу части функциональности. Зачастую связан не с тем, что функция не работает, а с тем, что она работает неправильно. В любом случае, существует более одной точки входа для инициации нужной функциональности. Так, вы можете покинуть помещение без использования ключа (дыра в безопасности), через вентиляцию (другая точка входа) или дверь открывается не в ту сторону (как следствие, упирается в угол и открывается только частично – некорректная реализация). Наиболее часто встречаются дефекты, которые можно отнести именно к этому уровню серьезности.
* S4 – Незначительный (Minor) – дефект, не относящийся к функциональности системы. Обычно серьезность Minor проставляется для тех дефектов, которые относятся к удобству использования или интерфейсу. По аналогии с помещением и дверью – на двери написано «От себя», хотя она открывается на себя, неудобное расположение замочной скважины и т.д.
* S5 – Тривиальный (Trivial) – дефект, не затрагивающий функциональность системы, а также оказывающий минимальное влияние на общее качество системы. Часто неотличим от уровня «minor». Обычно это грамматические дефекты в сопроводительной документации к системе. Иногда дефект относится к «невидимым» проблемам с точки зрения пользователя или пользовательского интерфейса и рассматривает сторонние библиотеки или сервисы, не относящиеся к самой разработанной системе. По аналогии с помещением и дверью – замок и ключ не одного производителя, в помещении слышится шум сверху (не относится к самому помещению) и т.д.

## 19. Приведите пример Низкого Priority и Высокого Severity.
Такое сочетание бывает у багов, которые возникают в отдельных функциях программы. Эти баги не позволяют пользоваться системой, при этом обойти их невозможно. Но сами функции, содержащие эти дефекты, конечным потребителем используются  редко.

### Примеры:

* Домашняя страница сайта ужасно выглядит в старых браузерах. Перекрывается текст, не загружается логотип. Это мешает пользоваться продуктом, поэтому серьезность бага высокая. Но так как очень мало пользователей открывают сайт при помощи устаревшего браузера, такой баг получает низкий приоритет.
* Допустим, у нас есть приложение для банкинга. Оно правильно рассчитывает ежедневный, ежемесячный и ежеквартальный отчет, но при расчете годового возникают проблемы. Этот баг имеет высокую степень серьезности. Но если сейчас формирование годовой отчетности не актуально, такой дефект имеет низкий приоритет: его можно исправить в следующем релизе.
* редкость проявления дефекта/сложность воспроизведения для юзеров.
* невозможность попасть на страницу комментариев к товару — можно отнести к этой области. В этом процессе произошел сбой в свойствах системы; однако, поскольку этот сбой не относится к основному потоку, его целесообразно классифицировать на этом уровне.

## 20. Приведите пример Низкого Severity и Высокого Priority.
Дефекты с низкой серьезностью, но высоким приоритетом, как правило, связаны с косметическими проблемами или незначительными неудобствами для пользователей, которые, тем не менее, могут повлиять на репутацию продукта или бизнес-процессы компании.

### Примеры:
* Кнопки перекрывают друг друга. Они кликабельны, но визуальное впечатление портится.
* Логотип компании на главной странице содержит орфографическую ошибку. На функционал это вообще не влияет, но портит пользовательский опыт. Этот баг нужно исправить с высоким приоритетом, несмотря не то, что на продукт он влияет минимально.

## 21. Что такое матрица соответствия требований (Requirements Traceability Matrix)?

Трассируемость (traceability): Способность идентифицировать связанные объекты в документации и программном обеспечении, например, требования со связанными с ними тестами. (ISTQB)
Матрица трассируемости (traceability matrix): Двумерная таблица, описывающая связь двух сущностей (например, требований и тестовых сценариев). Таблица позволяет производить прямую и обратную трассировку от одной сущности к другой, обеспечивая таким образом возможность определения покрытия и оценки влияния предполагаемых изменений. (ISTQB)

Матрица трассируемости (Requirement Traceability Matrix AKA Traceability Matrix or Cross Reference Matrix) используется для документирования связей между требованиями и тест-кейсами по этим требованиям и наглядного отображения трассируемости в виде простой таблицы.
Матрица трассируемости может служить одновременно в качестве матрицы покрытия. Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет.

### Типы матриц
RTM можно классифицировать в зависимости от их назначения и направления прослеживаемости:
* Прямая прослеживаемость: Сопоставляет требования с соответствующими проектными документами, кодом и тестовыми случаями. Это помогает гарантировать, что все требования реализованы.
* Обратная прослеживаемость: Связывает результаты и тестовые случаи с их исходными требованиями, гарантируя, что ничего не было добавлено без обоснования или что дополнительные функции не были включены непреднамеренно.
* Двунаправленная отслеживаемость: Обеспечивает как прямую, так и обратную прослеживаемость, предлагая комплексное представление связей между требованиями, результатами проекта и тестовыми случаями. Этот тип RTM обеспечивает полное покрытие, отслеживая требования от начала до конца и наоборот.

Понимая назначение, ключевые компоненты и типы RTM, проектные группы могут эффективно использовать этот инструмент для управления сложными требованиями, снижения рисков и обеспечения успеха проекта.

## 22. Что такое тест-отчет?
* Отчет о тестировании (Test report) – вид тестовой документации, который обобщает опыт проведенных QA-мероприятий. Он может быть разных типов, от этого зависит его содержание. Отчет о тестировании служит для принятия соответствующих решений в IT-проекте.
* Отчет (Report) - это документ, содержащий информацию о выполненных действиях, результатах проведённой работы. Обычно он включает в себя таблицы, графики, списки, просто описывающую информацию в виде текста. Их пропорция и содержание определяют пользу и понятность отчета.

## 23. По времени Тест отчет на сколько типов возможно разделить?
### Отчеты по тестированию программного обеспечения классифицируют по времени:
* Недельный, месячный, промежуточный. В подобных отчетах тестировщик указывает две основные метрики: уровень готовности, оценку проведенного тестирования; В общем, это практически тот же финальный отчет, но с измененными приоритетами фокуса и уменьшенной глубиной временной выборки. 
* Версионный. Похож на финальный отчет. Здесь указывают, какие задачи выполнялись командой, работающей над проектом. Делается в конце работы над каждой версией приложения;
* Финальный, или заключительный. Прописывается эволюция продукта, описывается общий взгляд на сделанную работу. Также, надо дать исчерпывающую информацию о статусе продукта в данный момент (количество оставшихся неисправленных ошибок, полностью ли протестирован продукт или требуется дополнительный цикл тестирования, оценка возможности выпуска продукта во «внешний мир» и т.д).
### QA-отчеты делятся на два вида:
* Промежуточный (Progress-report)
Промежуточный отчет составляется и отправляется на всех заинтересованных лиц после проведения каждого вида тестов. Данный тип отчета составляет инженер по тестированию, проверивший заданную часть функциональности. 
* Итоговый (Final report)
В конце предопределенного промежутка времени (обычно за неделю либо перед выходом очередной сборки) составляется итоговый отчет о всей проделанной работе. В отчете отражена информация о качестве всех проведенных видов тестов. Как правило, такой отчёт составляет ведущий тестировщик либо руководитель QA-команды. Он анализирует всю информацию о состоянии ПО и собирает её воедино.

## 24. Что должен показывать Промежуточный отчет?
Промежуточный отчёт составляется и отправляется на всех заинтересованных лиц после проведения каждого вида тестов. Данный тип отчёта составляет инженер по тестированию, проверивший заданную часть функциональности. 

## 25. Что должен показывать Итоговый отчет?
В конце предопределённого промежутка времени (обычно за неделю либо перед выходом очередной сборки) составляется итоговый отчёт о всей проделанной работе. В отчёте отражена информация о качестве всех проведённых видов тестов. Как правило, такой отчёт составляет ведущий тестировщик либо руководитель QA-команды. Он анализирует всю информацию о состоянии ПО и собирает её воедино.

# Баги

## 26. Что такое Ошибка/Дефект/Отказ?

* Ошибка — согласно ISTQB, любое действие человека, которое вызвало неверный результат. Ошибки могут быть допущены разработчиками, тестировщиками или пользователями. Ошибки могут вызвать дефекты, если они не будут обнаружены и исправлены.
* Дефект (баг) — изъян в компоненте или системе, который может привести компонент или систему к невозможности выполнить требуемую функцию (ISTQB). Это несоответствие между ожидаемым результатом и фактическим поведением системы. Дефект может быть вызван ошибкой в коде, неправильной конфигурацией системы или другими факторами. Дефекты могут привести к сбоям и отказам, если их не обнаружить и не исправить.
* Отказ — (определение с ISTQB) – событие, при котором система не выполняет ожидаемую функцию. Это постоянное нарушение работы системы, которое делает её непригодной для использования. Отказы могут быть вызваны серьезными дефектами или ошибками, которые не были обнаружены и исправлены. Отказы требуют серьезного вмешательства для восстановления работоспособности системы.
* Сбой — это временное нарушение работы системы, которое может привести к неправильному результату или поведению. Сбои могут быть вызваны внешними факторами, такими как отключение электроэнергии или ошибка пользователя. Сбои обычно восстанавливаются автоматически или вручную. Следовательно, разработчик может допустить ошибку, написав некорректный код. При работе функций приложения эта ошибка становится дефектом, который должен найти тестировщик. Дефект может вызвать сбой или отказ.

## 27. Перечислите Основные типы багов?
### Некоторые из типов багов, которые часто встречаются в тестировании ПО:
* Воспроизводимый (Reproducible Bug) — баг, который может быть воспроизведен тестировщиком в тестовом окружении.
* Не воспроизводимый (Non-reproducible Bug) — баг, который не может быть воспроизведен тестировщиком в тестовом окружении.
* Фатальный (Fatal Bug) — баг, который вызывает крах или аварийное завершение программы.
* Не фатальный (Non-fatal Bug) — баг, который не вызывает крах программы, но может приводить к некорректному поведению или неправильным результатам.
* Функциональный (Functional Bug) — баг, связанный с неправильной работой функциональности программы.
* Нефункциональный (Non-functional Bug) — баг, связанный с аспектами производительности, надежности, безопасности и т.д. программы.
* Интерфейсный (Interface Bug) — баг, связанный с интерфейсом пользователя.
* Синтаксический (Syntax Bug) — баг, связанный с нарушением правил синтаксиса языка программирования.
* Логический (Logical Bug) — баг, связанный с неправильной логикой работы программы.
* Спецификационный (Specification Bug) — баг, связанный с нарушением требований к программе, указанных в спецификации.
* Визуальный (Visual Bug) — баг, связанный с отображением графических элементов программы.
* Локализационный (Localization Bug) — баг, связанный с неправильным отображением или переводом программы на другие языки.
* Неоднозначный (Ambiguous Bug) — баг, который может иметь несколько причин и неоднозначный результат.
* Потенциальный (Potential Bug) — баг, который еще не проявился, но может возникнуть в будущем при определенных условиях.
* Дублирующий (Duplicate Bug) — баг, который уже был зарегистрирован и описан ранее.
### Некоторые дополнительные типы багов, которые можно упомянуть:
* Регрессионный (Regression Bug) — баг, который возникает после внесения изменений в программу, которые влияют на ее ранее исправно работающую функциональность.
* Перформанс (Performance Bug) — баг, связанный с падением производительности или задержками в работе программы.
* Надежности (Reliability Bug) — баг, связанный с неправильной работой программы при повторяемых условиях или при высокой нагрузке.
* Конфигурационный (Configuration Bug) — баг, связанный с неправильными настройками, конфигурацией программы или окружения, в котором она запускается.
* Системный (System Bug) — баг, связанный с неправильной работой операционной системы, на которой запущена программа.
* Сегментационный (Segmentation Bug) — баг, который возникает при попытке обращения к несуществующей памяти или доступе к запрещенной области памяти.
* Шумный (Noise Bug) — баг, который возникает из-за случайных факторов, таких как электромагнитные помехи, внешние воздействия и т.д.
* Косвенный (Indirect Bug) — баг, который проявляется не сразу, а через определенное время или взаимодействие с другими элементами программы.
* Интерфейсный (Interface Bug) — баг, связанный с неправильным взаимодействием разных элементов пользовательского интерфейса.
* Консистентности (Consistency Bug) — баг, связанный с неправильной и непоследовательной работой программы в разных частях или функциях.
* Компиляционный (Compilation Bug) — баг, который возникает в процессе компиляции программного кода.
* Миграционный (Migration Bug) — баг, связанный с неправильной работой программы при переносе ее с одной платформы на другую.
* Интернационализационный (Internationalization Bug) — баг, связанный с неправильной работой программы при использовании разных языков и культурных настроек.
* Полезности (Usability Bug) — баг, связанный с трудностью использования программы для конечного пользователя.
* Безопасности (Security Bug) — баг, связанный с уязвимостью программы, которая может привести к небезопасным действиям или утечке конфиденциальной информации.

## 28. Перечислите "Хитрые баги"?
### Что такое хитрые баги?

Хитрые баги — это скрытые дефекты, которые трудно обнаружить из-за специфических условий их возникновения. Они могут проявляться нерегулярно, в зависимости от конфигурации системы, загрузки или временных факторов.

Некоторым из таких багов даны названия, отражающие их природу, названия эти специфические и редко применяемые, и услышать их можно разве что на конференциях. Рассмотрим несколько типов таких «хитрых» багов, и причины их возникновения.

1. Баги гонки (Race Condition):
Возникают, когда несколько процессов или потоков пытаются одновременно получить доступ к общему ресурсу, что приводит к непредсказуемому поведению. Эти баги часто зависят от скорости выполнения и могут не проявляться в обычных условиях.

Пример: В приложении для бронирования авиабилетов два пользователя одновременно пытаются забронировать последнее место. Если система не синхронизирует эти действия должным образом, оба пользователя могут получить подтверждение бронирования, что приведет к двойному бронированию. Это происходит из-за конкуренции за один и тот же ресурс (последнее место), когда оба процесса исполняются почти одновременно 

2. Баги, связанные с памятью (Memory Leaks):
Это ошибки, при которых программа неправильно управляет памятью, не освобождая её после использования. Такие баги могут накапливаться и проявляться только после длительной работы программы, когда объём используемой памяти значительно возрастает.

Пример: В браузере приложение активно загружает динамический контент на странице, но при каждом обновлении данные остаются в памяти. Если приложение не освобождает память после завершения операции, объем используемой памяти будет расти, что приведет к медленной работе браузера и, в конечном итоге, к его сбою

3. Баги синхронизации:
Эти баги связаны с нарушением правильного порядка выполнения операций, что приводит к ошибкам, которые трудно предсказать. Например, операция, которая должна была завершиться до другой, выполняется позже.

Пример: В системе управления складом инвентаризация проводится одновременно с отгрузкой. Если данные об изменениях на складе не синхронизируются между процессами вовремя, это может привести к некорректным данным о количестве товара, и система может показать, что на складе есть товар, которого на самом деле нет

4. Баги, связанные с зависимостями от внешних систем:
Проявляются, когда программа взаимодействует с внешними сервисами или системами, например, при временных сбоях сети или сервера. Эти баги сложно воспроизвести, так как они зависят от внешних факторов.

Пример: Приложение для обработки платежей зависит от стороннего API банка. Если API временно недоступен или возвращает неожиданные ошибки, приложение может неправильно обработать транзакции, даже если на стороне пользователя всё корректно

5. Баги, связанные с конфигурацией окружения (Environment-Specific Bugs):
Такие баги возникают только в определённых окружениях, например, на специфических устройствах, в определённых операционных системах или версиях браузеров.

Пример: Веб-приложение работает корректно в Google Chrome, но в браузере Safari интерфейс отображается неправильно из-за различий в рендеринге CSS. Этот баг проявляется только в определённых браузерах или на специфических устройствах

6. Интермиттирующие баги (Intermittent Bugs):
Эти баги проявляются нерегулярно и часто не воспроизводятся при повторном запуске тестов, что делает их особенно сложными для диагностики.

Пример: В мобильном приложении ошибка воспроизведения медиафайлов возникает только иногда, когда устройство подключено к слабой сети Wi-Fi. Этот баг трудно отследить, так как он проявляется нерегулярно и зависит от внешних условий, таких как качество соединения

7. Баги, связанные с конкурентными запросами (Concurrency Issues):
Возникают, когда множество пользователей или процессов одновременно пытаются выполнить одну и ту же операцию. Часто такие баги выявляются при стресс-тестировании.

Пример: В высоконагруженной базе данных несколько запросов одновременно пытаются изменить одну и ту же запись. Если система не блокирует корректно доступ к записи для других запросов, данные могут быть повреждены или недоступны для других пользователей

8. Баги, зависящие от времени (Time-Sensitive Bugs):
Эти баги проявляются только в определённое время (например, баги, связанные с переходом времени, обновлением часов, календаря или часовыми поясами).

Пример: Приложение для учёта времени не обновляет данные о времени корректно во время перехода на летнее время. Это может привести к некорректным расчетам рабочих часов или сбоям в планировке задач, которые зависят от точного времени

9. Гейзенбаг
это баг, который исчезает или меняет свое поведение, как только его пытаются изучить или отладить.

Пример:
Пользователь сталкивается с ошибкой в балансе счета, но при попытке воспроизвести баг — баланс всегда отображается корректно.

10. Борбаг
это баг, который проявляется постоянно, но только при определенных условиях или входных данных.

Пример:
Функция в приложении выдает ошибку только при очень медленном сетевом подключении.

11. Мандельбаг
это баг с чрезвычайно сложным и непредсказуемым поведением, часто вызванный глубокими архитектурными дефектами системы.

Пример:
В видеоиграх персонажи застревают в объектах или машины внезапно взлетают на ровной дороге. Эти баги остаются неисправленными даже спустя годы после релиза.

12. Шрединбаг
это баг, который проявляется только при определённых условиях и может исчезнуть при попытке изучения кода. Как и в парадоксе Шрёдингера, баг как бы «существует и не существует одновременно», пока его не начнут тестировать.

Пример:
Функция программы выдает некорректные результаты только в присутствии конкретного пользователя с определенной конфигурацией прав доступа.

13. Лунный баг
это баг, который проявляется только в определённое время, зависимо от даты или времени суток. Он может возникнуть из-за скрытых временных параметров в коде, что делает его сложным для обнаружения и воспроизведения.

Пример:
В приложении магазина код скидки работает нормально весь месяц, но в последний день месяца почему-то перестает функционировать.

14. Статистический баг
это баг, который не проявляется при одном прогоне, но возникает при многократном выполнении кода, генерирующего случайные или псевдослучайные результаты.

Пример:
Программа для бизнес-моделирования выдает незначительные отклонения в результатах, которые со временем накапливаются, искажают данные и приводят к некорректным выводам при анализе больших объемов данных.

15. Гинденбаг 
это баг, который может привести к катастрофическим последствиям для системы, особенно в критически важных инфраструктурах или колоссальным  финансовым убыткам.

Пример:
Ошибка в программном обеспечении управления полетом, которая приводит к краху спутника, или баг в банковской системе, который приводит к миллиардным потерям.

16. Баг Хиггса 
это баг, существование которого предсказано или предполагается, но на практике его невозможно обнаружить. Он может существовать только «теоретически», из-за ошибки в логике кода, но никогда не проявляется при реальном использовании.

Пример:
Ошибка в логике программы, которая, по всем расчетам, должна вызывать сбой, но ни тестировщики, ни разработчики не могут её воспроизвести — система работает идеально.

## 29. Приведите пример Blocker bug
"Blocker bug" - это термин, используемый в разработке программного обеспечения для обозначения критической ошибки, которая препятствует нормальной работе системы. Такие ошибки могут быть серьёзным препятствием для продолжения разработки или использования программного продукта. Вот пример "blocker bug":
Предположим, у веб-приложения для онлайн-торговли обнаруживается ошибка, из-за которой пользователи не могут завершить процесс оплаты. Даже после ввода всех данных оплаты и подтверждения покупки, пользователи получают сообщение об ошибке и платеж не проходит. Это могло бы быть классифицировано как "blocker bug", потому что оно непосредственно влияет на ключевую функциональность приложения, препятствует завершению транзакций и, таким образом, препятствует основной цели приложения – совершению покупок.
Команда разработки немедленно займется этой проблемой, поскольку она негативно влияет на бизнес и пользователей. Обычно такие проблемы имеют высокий приоритет и рассматриваются как неотложные для решения.
 
## 30. Приведите пример Critical bug
"Critical bug" - это термин, который обычно используется для обозначения серьезной ошибки в программном обеспечении, которая может привести к серьезным последствиям, таким как потеря данных, системный сбой или угроза безопасности.
В медицинской информационной системе существует ошибка, из-за которой результаты анализов пациентов периодически перепутываются, что может привести к неправильному назначению лечения. Это критическая ошибка, так как она прямо влияет на здоровье пациентов и может иметь серьезные медицинские последствия.
Команда разработки и ИТ-специалисты должны тут же приступить к идентификации и устранению этой проблемы, поскольку она может привести к непоправимым последствиям и имеет прямое отношение к здоровью и благополучию людей.
 
## 31. Приведите пример Major bug 
"Major bug" - это термин, обозначающий значительную ошибку в программном обеспечении, которая может вызвать серьезное нарушение функциональности, но, в отличие от critical bug, не представляет угрозы для безопасности или жизненно важных функций.
 веб-приложении для онлайн-покупок скидка в 50% автоматически применяется ко всем товарам в корзине, независимо от их типа или бренда. Это приводит к значительным потерям прибыли для компании, поскольку скидка не должна автоматически применяться к определенным товарам или брендам. Этот дефект серьезно влияет на финансовые показатели компании, но не представляет угрозы для безопасности или жизненно важных функций.
Для решения данной проблемы команда разработки и техническая поддержка должны провести тщательное тестирование и исправить это поведение, чтобы избежать потерь прибыли и обеспечить правильную работу системы онлайн-продаж.
Исправление major bug является важным, поскольку оно напрямую влияет на опыт пользователей и финансовую устойчивость компании, но не требует немедленной реакции, как это случается с critical bug.

## 32. Приведите пример Minor bug
Минорная ошибка (minor bug) обычно является незначительным дефектом в программном обеспечении, который не приводит к серьезным нарушениям работы системы и не влияет на ее ключевую функциональность. Вот пример такой ошибки:
В текстовом редакторе неверно отображается количество слов в документе в случае, если в тексте присутствуют знаки препинания и специальные символы. Например, при наличии апострофов или дефисов количество слов может быть неверно посчитано. Хотя это может быть раздражающим, особенно для людей, которые работают с текстом, это не представляет критической проблемы и не влияет на возможность сохранения и редактирования документов.
Для решения такой ошибки команда разработки может рассмотреть оптимизацию алгоритма подсчёта слов в тексте и обновить соответствующий функционал без причинения значительных помех в общей работоспособности программы.
 
## 33. Приведите пример Trivial bug
Trivial bug (мелкая ошибка) обычно представляет собой наименее значимый тип дефекта в программном обеспечении. Вот пример такой ошибки:
В текстовом редакторе в подменю "Стиль" встречается опечатка – вместо "Курсив" написано "Курсивв". Это незначительная опечатка в пользовательском интерфейсе, которая не влияет на возможность пользователей изменять форматирование текста в документах.
Для решения такой ошибки команда разработки может просто обновить текст в пользовательском интерфейсе без внесения каких-либо изменений в программную логику, поскольку эта опечатка не влияет на общее функционирование программы.
 
## 34. Какие основные цели локализации дефекта?
* Выявление и диагностика проблемы
* Снижение риска
* Повышение удовлетворенности пользователей
* Сбор информации о дефектах
* Оптимизация процесса тестирования
* Повышение эффективности отладки
* Обеспечение качества
* Улучшение взаимодействия с командой

## 35. Где могут находиться дефекты? 
* Исходный код
* Интерфейс пользователя (UI)
* Back-end и серверная часть
* Базы данных
* Интеграция с внешними системами
* Настройки конфигурации
* Производительность и нагрузки
* Безопасность
* Система и окружение
* Процессы и требования
* Документация

## 36. Перечислите методы локализации дефекта в клиентской части
1. Тестирование на разных устройствах/браузерах: Проверка работоспособности приложения в разных браузерах и на разных устройствах, так как дефекты могут быть специфичны для определенной платформы.
2. Инспектирование DOM: Визуальный анализ структуры страницы через инспектор в браузере для поиска проблем с версткой, CSS и взаимодействиями элементов.
3. Логи браузера/консоль разработчика: Проверка ошибок и предупреждений в консоли разработчика в браузере (F12). Это помогает выявить JavaScript ошибки, сетевые запросы, проблемы с загрузкой ресурсов и другие ошибки.
* Логи — это записи событий и сообщений, создаваемые программой или системой во время ее работы. Они представляют собой источник информации о том, что происходит внутри приложения в определённый момент времени.
* Виды логов - Логи приложения, логи сервера, системные логи.
4. Отладка (debugging) — этап разработки компьютерной программы, на котором обнаруживают, локализуют и устраняют ошибки.
5. Инструменты сетевого мониторинга: Использование вкладки "Сеть" (Network) в консоли разработчика браузера для анализа сетевых запросов, ответа сервера, заголовков и статусов HTTP.
6. Анализ производительности (Performance): Изучение вкладки "Performance" для выявления проблем с производительностью клиентской части, таких как долгие загрузки или утечки памяти.
7. Перезапуск с кешем и без кеша: Очистка кеша и повторная загрузка страницы для исключения проблем, связанных с кешированием.
* Кэш — это память программы или устройства, которая сохраняет временные или часто используемые файлы для быстрого доступа к ним.
* Есть два типа кэш-памяти:
        * Аппаратная кэш-память — память системы. Свой кэш есть у жёсткого диска, графического ускорителя и процессора.
        * Программная кэш-память — это папки на диске устройства, в которых программы и сервисы сохраняют свои файлы для быстрого доступа.
Кэш нужно чистить, чтобы увеличить скорость работы программ и предотвратить ошибки в них.

* Cookie (куки) — это небольшие фрагменты данных, которые содержат информацию о пользователе и его действиях на сайте.
8. Эмуляция/симуляция мобильных устройств: Использование инструментов эмуляции и симуляции для проверки отображения и работы на разных на мобильных устройствах.
9. Fiddler/Charles Proxy: Для перехвата и анализа сетевых запросов, когда нужно глубже проанализировать обмен данными между клиентом и сервером.

## 37. Перечислите методы локализации дефекта в серверной части
1. Анализ HTTP-ответов: Проверка статусов HTTP-ответов, содержимого тела ответа и заголовков с помощью инструментов браузера или сетевых утилит. Это позволяет понять, есть ли ошибки со стороны сервера (например, 500 Internal Server Error).
* Вспомним уже приведенные выше примеры. Можно сказать, что тестирование через вкладку network в devtools в первую очередь помогает анализировать Frontend, а именно, как браузер взаимодействует с сервером. Основное внимание уделяется тому, как пользовательский интерфейс и браузер отправляют запросы и обрабатывают ответы от сервера.
* Там мы больше наблюдаем за тем, как frontend взаимодействует с backend, а не как сам backend функционирует.
* Charles Proxy используется больше для перехвата и анализа реальных запросов между клиентом и сервером (как в браузере, так и в мобильных приложениях), а также для модификации и мониторинга сетевого трафика.
* Поэтому для тестирование самой backend части и прямого тестирования API больше подойдут такие программы как Postman и SoupUI.
2. Postman: Использование инструментов для отправки API-запросов напрямую к серверу для проверки корректности обработки запросов и ответов без участия клиентской части.
3. Логи сервера: Просмотр серверных логов, чтобы выявить ошибки или исключения, возникающие на сервере при выполнении запросов.
#### Для этой задачи используют такие программы как:
* Graylog
* GoAccess
* ELK Stack (Elasticsearch, Logstash, Kibana)
4. Мониторинг серверных ресурсов: Анализ нагрузки на сервер, доступности ресурсов (CPU, память, диск) с помощью мониторинговых систем, чтобы понять, не является ли дефект следствием нехватки ресурсов.
#### Основные программы:
* htop / top (Linux, macOS) – для мониторинга ресурсов в реальном времени.
* Task Manager / Resource Monitor (Windows) – встроенные инструменты для просмотра использования CPU, памяти и сети.
* Prometheus + Grafana – сбор и визуализация данных о состоянии сервера и его ресурсов.
* Netdata – лёгкий и наглядный мониторинг ресурсов в реальном времени через веб-интерфейс.
* Zabbix – для глубокого мониторинга IT-инфраструктуры с уведомлениями.
* Nagios – для мониторинга серверов и сервисов с возможностью настройки плагинов.
* New Relic – облачное решение для мониторинга серверов и приложений.
5. Дебаг на стороне сервера: Совместная работа с разработчиками для использования отладочных инструментов сервера (например, отладка с помощью IDE или других инструментов логирования).
6. Анализ базы данных: Проверка запросов к базе данных на правильность, выполнение и результаты с помощью инструментов мониторинга БД (например, SQL-запросы, используемые сервером).
* Логирование запросов к базе данных: Включение логов SQL-запросов (например, в MySQL можно включить slow query log) помогает выявить медленные запросы, ошибки при выполнении запросов, неправильное использование индексов и др.
* Анализ производительности запросов (Query Profiling): Инструменты профилирования запросов, такие как EXPLAIN в MySQL, позволяют анализировать, как база данных выполняет запросы. Это помогает понять, где возникают проблемы, такие как медленные JOIN-ы, отсутствие индексов или неправильное использование функций.
* Мониторинг базы данных: Инструменты мониторинга, такие как MySQL Workbench, Percona Monitoring and Management (PMM) или Grafana с подключением к базе, могут помочь отслеживать использование ресурсов базы данных (память, CPU, дисковые операции). Это помогает выявить потенциальные проблемы производительности.
* Тестирование целостности данных: Использование скриптов для проверки консистентности данных, чтобы убедиться, что данные не повреждены, отсутствуют или не искажены при операциях записи и чтения.
7. Тестирование кэширования: Проверка корректности работы серверного кэширования, например, как сервер обрабатывает повторяющиеся запросы и обновляет данные.
* Redis и Memcached: Для серверного кэширования часто используются Redis и Memcached. Их нужно тестировать на корректную работу в плане производительности и хранения данных.
* Varnish Cache: Может быть использован для кэширования HTTP-ответов, что особенно полезно для веб-приложений с высокой нагрузкой.
#### Примеры методов и подходов:
* Валидация данных в кэше - Проверка свежести данных. Убедится, что кэшированные данные актуальны и обновляются при изменении оригинальных данных в базе. Например, если пользователь изменил данные, кэш должен обновиться.
* Тестирование кэширования на уровне API - Проверка кэширования HTTP-заголовков. Убедится, что сервер корректно использует HTTP-заголовки кэширования, такие как Cache-Control, ETag, Expires, чтобы клиенты могли повторно использовать кэшированные данные.
* Анализ возможных проблем с кэшем - Проверить, что кэширование не дублируется на нескольких уровнях (например, кэш на уровне базы данных, на уровне приложения и HTTP), так как это может вызвать проблемы с синхронизацией данных.
